===================================================================
P0020r3 : Floating Point Atomic
===================================================================

:Project: ISO JTC1/SC22/WG21: Programming Language C++
:Number: P0020r3
:Date: 2016-10-14
:Reply-to: hcedwar@sandia.gov
:Author: H\. Carter Edwards
:Contact: hcedwar@sandia.gov
:Author: Hans Boehm
:Contact: hboehm@google.com
:Author: Olivier Giroux
:Contact: ogiroux@nvidia.com
:Author: JF Bastien
:Contact: jfb@google.com
:Author: James Reus
:Contact: reus1@llnl.gov
:Audience: SG1 Concurrency, Library Evolution
:URL: https://github.com/kokkos/ISO-CPP-Papers/blob/master/P0020.rst


******************************************************************
Motivation
******************************************************************

This paper proposes an extension to the atomic operations library [atomics]
for atomic addition on an object conforming to the atomic<T> where T is
a *floating point* type (N5131 3.9.1p8).

This paper **does not** include proposed extension
of the named atomic type (N5131 Tables 134 and 135),
or by implication extension of the C \_Atomic qualification
for *floating* types.

The capability for atomic addition on floating point types
critical for high performance computing (HPC) applications.
The need is for extension of *atomic* and
*atomic_view* (P0019) for floating point types.


******************************************************************
Proposal
******************************************************************

-------------------------------------------
*add to* 29.2 Header <atomic> synopsis
-------------------------------------------

  |  namespace std {
  |    template<> stuct atomic< *floating* >;
  |  }

-------------------------------------------
*add to* 29.5 Atomic Types
-------------------------------------------

  |  template<> struct atomic< *floating* > {
  |    static constexpr size_t required_alignment = *implementation-defined* ;
  |    static constexpr bool is_always_lock_free = *implementation-defined* ;
  |    bool is_lock_free() volatile noexcept;
  |    bool is_lock_free() noexcept;
  |    void store( *floating* , memory_order = memory_order_seq_cst ) volatile noexcept;
  |    void store( *floating* , memory_order = memory_order_seq_cst ) noexcept;
  |    *floating* load( memory_order = memory_order_seq_cst ) volatile noexcept;
  |    *floating* load( memory_order = memory_order_seq_cst ) noexcept;
  |    operator *floating* () volatile noexcept ;
  |    operator *floating* () noexcept ;
  |    *floating* exchange( *floating* , memory_order = memory_order_seq_cst ) volatile noexcept;
  |    *floating* exchange( *floating* , memory_order = memory_order_seq_cst ) noexcept;
  |    bool compare_exchange_weak( *floating* & , *floating* , memory_order , memory_order ) volatile noexcept;
  |    bool compare_exchange_weak( *floating* & , *floating* , memory_order , memory_order ) noexcept;
  |    bool compare_exchange_strong( *floating* & , *floating*  , memory_order , memory_order ) volatile noexcept;
  |    bool compare_exchange_strong( *floating* & , *floating*  , memory_order , memory_order ) noexcept;
  |    bool compare_exchange_weak( *floating* & , *floating*  , memory_order = memory_order_seq_cst ) volatile noexcept;
  |    bool compare_exchange_weak( *floating* & , *floating*  , memory_order = memory_order_seq_cst ) noexcept;
  |    bool compare_exchange_strong( *floating* &, *floating* , memory_order = memory_order_seq_cst ) volatile noexcept;
  |    bool compare_exchange_strong( *floating* &, *floating* , memory_order = memory_order_seq_cst ) noexcept;
  |
  |    *floating* fetch_add( *floating* , memory_order = memory_order_seq_cst) volatile noexcept;
  |    *floating* fetch_add( *floating* , memory_order = memory_order_seq_cst) noexcept;
  |    *floating* fetch_sub( *floating* , memory_order = memory_order_seq_cst) volatile noexcept;
  |    *floating* fetch_sub( *floating* , memory_order = memory_order_seq_cst) noexcept;
  |
  |    constexpr atomic() noexcept ;
  |    atomic( atomic && ) noexcept ;
  |    atomic( const atomic & ) noexcept ;
  |    atomic & operator = ( atomic && ) noexcept ;
  |    atomic & operator = ( const atomic & ) noexcept ;
  |    *floating* operator=( *floating* ) volatile noexcept ;
  |    *floating* operator=( *floating* ) noexcept ;
  |
  |    *floating* operator+=( *floating* ) volatile noexcept;
  |    *floating* operator+=( *floating* ) noexcept;
  |    *floating* operator-=( *floating* ) volatile noexcept;
  |    *floating* operator-=( *floating* ) noexcept;
  |  };

-------------------------------------------------------------------------
*add to* 29.6.3 Arithmetic operations on atomic types
-------------------------------------------------------------------------

In the declarations of these functions and function template specializations,
the name *floating* refers to a floating point type and the name
*atomic-floating* refers to **atomic<** *floating* **>**.

-------------------------------------------------------------------------
*insert in* 29.6.5 Requirements for operations on atomic types
-------------------------------------------------------------------------

*regarding arithmetic operations*

| **C A::fetch_**\ *key*\ **(M operand, memory_order order = memory_order_seq_cst) volatile noexcept;**
| **C A::fetch_**\ *key*\ **(M operand, memory_order order = memory_order_seq_cst) noexcept;**

*append to 29.6.5p31 Remark*

  For *floating* types, if the result is not mathematically defined or
  not in the range of representable values for its type (5p4),
  the result is undefined but the operations otherwise have no
  undefined behavior.
  [Note:  Atomic arithmetic operations on *floating* types
  *should* conform to **std::numeric_limits<** *floating* **>** (18.3.2)
  traits associated with the floating point type.
  The floating point environment (26.4) for atomic arithmetic operations
  on *floating* type may be different than the calling thread's
  floating point environment.  - end note]

******************************************************************
Revision History
******************************************************************

------------------------------------------------------------
P0020r3
------------------------------------------------------------

  - Align proposal with content of corresponding sections in N5131, 2016-07-15.

