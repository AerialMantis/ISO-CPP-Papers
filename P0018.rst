===================================================================
P0018r01 : Lambda Capture of \*this by Value
===================================================================

:Author: H\. Carter Edwards
:Contact: hcedwar@sandia.gov
:Author: Christian Trott
:Contact: crtrott@sandia.gov
:Author: Hal Finkel
:Contact: hfinkel@anl.gov
:Author: Jim Reus
:Contact: reus1@llnl.gov
:Author: Robin Maffeo
:Contact: robin.maffeo@amd.com
:Author: Ben Sander
:Contact: ben.sander@amd.com
:Date: 2015-09-15
:Version: 01
:URL: https://github.com/kokkos/ISO-CPP-Papers/blob/master/P0018.rst
:WG21: Evolution Working Group (EWG)
:WG21: Concurrency and Parallelism Study Group (SG1)

.. sectnum::


************************************************************************
Issue
************************************************************************

Lambda expressions declared within a non-static member function explicilty
or implicitly captures **this** to access to member variables of **this**.
Both capture-by-reference **[&]** and capture-by-value **[=]** implicitly
capture the **this** pointer, therefore member variables are always accessed
by reference via **this**.
Thus the capture-default has no effect on the capture of **this**.

.. code-block:: c++

  struct S {
    int x ;
    void f() {
      // The following lambda captures are currently identical
      auto a = [&]() { x = 42 ; } // OK: transformed to (*this).x
      auto b = [=]() { x = 43 ; } // OK: transformed to (*this).x
      a();
      assert( x == 42 );
      b();
      assert( x == 43 );
    }
  };

.. /*


************************************************************************
Motivations for lambda capture of **\*this** by Value
************************************************************************

Truly capturing **\*this** by value allows an implicitly declared
closure to be copied before invoking the closure's functon.

Asynchronous dispatch of lambda
------------------------------------------------------------------------

Asynchronous dispatch of closures a cornerstone of parallelism
and concurrency.

When a lambda is asynchronously dispatched from within a
non-static member function, via **std::async**
or other concurrency / parallelism dispatch mechanism,
the enclosing **\*this** class *cannot* be captured by value.
Thus when the **future** (or other handle) to the dispatched lambda
outlives the originating class the lambda's captured **this**
pointer is invalid.

.. code-block:: c++

  class Work {
  private:
    int value ;
  public:
    Work() : value(42) {}
    std::future<int> spawn()
      { return std::async( [=]()->int{ return value ; }); }
  };

  std::future<int> foo()
  {
    Work tmp ;
    return tmp.spawn();
    // The closure associated with the returned future 
    // has an implicit this pointer that is invalid.
  }

  int main()
  {
    std::future<int> f = foo();
    f.wait();
    // The following fails due to the
    // originating class having been destroyed
    assert( 42 == f.get() );
    return 0 ;
  }

..

Dispatching asynchronous closures to data
------------------------------------------------------------------------

Current and future hardware architectures
specifically targeting parallelism and concurrency have
heterogeneous memory systems.
For example, NUMA regions, attached accelerator memory, and
processing-in-memory (PIM) stacks.
In these architectures it will often result in signficantly
improved performance if the closure is copied to the
data upon which it operates, as opposed to moving
the data to and from the closure.

For example, parallel execution of a closure on large data
spanning NUMA regions will be more performant if a copy
of that closure residing in the same NUMA region acts
upon that data.
If true a (self-contained) capture-by-value lambda closure
were given to a parallel dispatch, such as in the
parallelism technical specification, then the library could
create copies of that closure within each NUMA region to improve
data locality for the parallel computation.
For another example, a closure dispatched to an attached accelerator
with separate memory must be copied to the accelerator's
memory before execution can occur.
Thus current and future architectures *require* the capability
to copy closures to data.


Onerous work-around
------------------------------------------------------------------------

A potential work-around for this deficiency is to explicitly
copy the originating class and then capture that copy. 

.. code-block:: c++

  class Work {
  private:
    int value ;
  public:
    Work() : value(42) {}
    std::future<int> spawn()
      {
        Work tmp(*this);
        // Ambiguous as to whether The generated closure struct
        // has permission to access the private member 'value'.
        return std::async( [=]()->int{ return tmp.value ; });
      }
  };

.. /*

One issue is that it is ambiguous as to whether the closure
generated in this work-around has permission to access the
originating class' private member data.
If the closure does not have the appropriate permission then
an additional work-around is required to create a new member
function to perform the work that is intended for the lambda;
which defeats the usefulness of the lambda.
This workaround requires
(1) both the temporary copy and the capture copy of the originating class and
(2) all expressions within the lambda body must reference
the originating class' members via the temporary object name.

This work-around is onerous and counter-productive
to introducing asynchronously dispatched lambda expressions
within existing code.
Consder the case of replacing a **for** loop within a 
non-static member function with a *parallel for each* construct
as in the parallelism technical specification.

.. code-block:: c++

  class Work {
  public:
    void do_something() const {
      Work tmp(*this);
      // for ( int i = 0 ; i < N ; ++i )
      foreach( Parallel , 0 , N , [=]( int i )
      {
        // A modestly long loop body where
        // every reference to a member variable
        // or member function must be modified for
        // qualification with 'tmp.'
      }
      );
    }
  };

..

In this example every reference to a member
in the pre-existing code must be modified to
add the **tmp.** qualification.
This onerous process must be repeated throughout
an existing code base.
A true lambda capture of **\*this** would eliminate
such an onerous process of injecting parallelism
and concurrency into an large, existing code base.



Safety and productivity in parallelism and concurrency
------------------------------------------------------------------------

As currently specified integration of lambda and concurrency
capabilities is perilous, as demonstrated by the previous **Work** example.
A lambda generated within a non-static member function *cannot*
be a true (self-contained) closure and therefore cannot reliably
be used with an asynchronous dispatch.

Lambda capability is a significant boon to productivity,
especially when parallel or concurrent closures can be
defined with lambdas as opposed to manually generated functors.
If the capability to capture **\*this** by value
is not enabled then the productivity benefits of lambdas
cannot be fully realized in the parallelism and concurrency domain.


************************************************************************
Semantics of Lamda Capture of **\*this** by value
************************************************************************

Lambda captures of **\*this** by value within a non-static member function is as if:

- the implicitly generated closure object type is derived from the type of **\*this**,
- the closure object type is declared a **friend** of the of the type of **\*this**,
- the closure object type has **using** statements for all members of the type of **\*this** that are accessed within the lambda expression, and
- the **\*this** object is copy constructed into the closure object.

Requires: The type of **\*this** to be copy constructable.

Requires: Lambda capture of **\*this** by value does not occur within a copy constructor, or function invoked by a copy constructor, as this would result in a infinite recursion of the copy constructor.  This requirement would also be applicable to the onerous work-around.


************************************************************************
Resolution Option #1: Correct Lambda Capture-by-value **[=]**
************************************************************************

The semantically consistent resolution is for the *capture-default* **[=]**
to capture **\*this** by value for lambda expressions within a non-static
member function.
The *capture-default* **[&]** within a non-static member function
conforms to the current capture specification for **this**.


.. code-block:: c++

  struct S {
    int x ;
    void f() {
      auto a = [&]() { x = 42 ; } // OK: transformed to (*this).x
      auto b = [=]() mutable { x = 42 ; } // Modifying copy of x

      auto c = [=]() { x = 42 ; } // Error: captured copy of '*this'
                                  // and lambda function is 'const'
    }
  };

.. /*

This resolution would correct lambda capture semantics;
however, it is likely to break existing code.
As such we propose the following solution.


************************************************************************
Resolution Option #2: Add True Lambda Capture-by-value **[\*]**
************************************************************************

Given that the semantically consistent resolution would break
current standard behavior, a new capture mechanism is necessary
to provide semantically consistent capture-by-value semantics for
lambda expressions within non-status member functions.

Extend the *capture-default* and *simple-capture* to include:

  |  *capture-default*:
  |       &
  |       =
  |       \*
  |  *simple-capture*:
  |      *identifier*
  |      & *identifier*
  |      **this**
  |      **\*this**


The *simple-capture* **\*this** declares that **\*this**
is to be captured by value.
The *capture-default* **[\*]** declares that the default capture
is by value, including **\*this** if the lambda
expression appears within a non-static member function.
Outside of a non-static member function the *capture-default* **[\*]**
is identical to the *capture-default* **[=]**.

Nested lambda capture
------------------------------------------------------------------------

A new capture mechanism introduces a introduces new capture interaction.
For non-**\*this** captures the interactions remain unchanged.
When **\*this** is captured by value via **[\*]** nested captures
of **this** refer to the enclosing copy of **\*this**.

.. code-block:: c++

  void Work::foo()
  {
    auto x = [*]() { // *this is captured by value
      auto y = [&]() {
        // refer to the copy of Work contained in 'x'
        // does not refer to the original enclosing 'this'
        this->value
      };
      auto z = [=]() {
        // refer to the copy of Work contained in 'x'
        // does not refer to the original enclosing 'this'
        this->value
      };
    };
  }

..


Updated example
------------------------------------------------------------------------

With true lambda capture-by-value the earlier example 
can have the correct behavior by generating a complete closure.

.. code-block:: c++

  class Work {
  private:
    int value ;
  public:
    Work() : value(42) {}

    std::future<int> spawn()
      // Capture-by-value is correct and the asynchronously
      // dispatched closure may outlive the originating class,
      // and may be freely copied without losing correctness.
      { return std::async( [*]()->int{ return value ; }); }

    // Trivial change to replace 'for' with 'parallel for'
    void do_something() const {
      // for ( int i = 0 ; i < N ; ++i )
      foreach( Parallel , 0 , N , [=]( int i )
      {
        // A modestly long loop body where
        // every reference to a member variable
        // or member function can be referenced
        // without modification.
      }
      );
    }
  };

..


