===================================================================
P0018r01 : Lambda Capture of \*this by Value
===================================================================

:Author: H\. Carter Edwards
:Contact: hcedwar@sandia.gov
:Author: Christian Trott
:Contact: crtrott@sandia.gov
:Author: Robin Maffeo
:Contact: Robin.Maffeo@amd.com
:Author: Ben Sander
:Contact: ben.sander@amd.com
:Date: 2015-08-19
:Version: 01
:URL: https://github.com/kokkos/ISO-CPP-Papers/blob/master/P0018.rst
:WG21: Evolution

.. sectnum::


Issue
---------

Lambda expressions declared within a non-static member function explicilty
or implicitly captures **this** to access to member variables of **this**.
Both capture-by-reference **[&]** and capture-by-value **[=]** implicitly
capture the **this** pointer, therefore member variables are always accessed
by reference via **this**.
Thus the capture-default has no effect on the capture of **this**.

.. code-block:: c++

  struct S {
    int x ;
    void f() {
      // The following lambda captures are currently identical
      auto a = [&]() { x = 42 ; } // OK: transformed to (*this).x
      auto b = [=]() { x = 43 ; } // OK: transformed to (*this).x
      a();
      assert( x == 42 );
      b();
      assert( x == 43 );
    }
  };

.. /*


Motivation for Complete Capture by Value Capability
-----------------------------------------------------

Capturing by value allows the implicitly declared
closure to be copied before invoking the closure's functon.
This capability is necessary for current and future heterogeneous
architectures when explicitly moving computation to data yields significantly
better performance than moving data to computation.
For example moving a closure to the NUMA region, attached accelerator,
or processing-in-memory that is nearby the data.

Capturing by value improves robustness for the
asynchronous dispatch of a lambda generated
within a struct's non-static member function.
Without capture by value the lifetime of the generating
**\*this** must exceed the lifetime of the task.
With capture by value the generating **\*this**
may be destroyed since the lambda-task captured
a copy of **\*this**, as opposed to merely capturing
the **this** pointer.

A lambda capture by value declaration everywhere except
within a non-static member function is sufficient.
The inability for lambda capture of **\*this** by value
is a hole in the lambda capbility that must be addressed
for robustness of asynchronous execution and
performance portability across contemporary
and near-future heterogeneous architectures.




Semantics of Capturing **\*this** by value
-------------------------------------------

Lambda captures of **\*this** by value within a non-static member function is as if:

- the implicitly generated closure object type is derived from the type of **\*this**,
- the closure object type is declared a **friend** of the of the type of **\*this**,
- the closure object type has **using** statements for all members of the type of **\*this** that are accessed within the lambda expression, and
- the **\*this** object is copy constructed into the closure object.

Requires: The type of **\*this** to be copy constructable.


Resolution Option #1: Correct Lambda Capture-by-value **[=]**
---------------------------------------------------------------------

The semantically consistent resolution is for the *capture-default* **[=]**
to capture **\*this** by value for lambda expressions within a non-static
member function.
The *capture-default* **[&]** within a non-static member function
conforms to the current capture specification for **this**.


.. code-block:: c++

  struct S {
    int x ;
    void f() {
      auto a = [&]() { x = 42 ; } // OK: transformed to (*this).x
      auto b = [=]() mutable { x = 42 ; } // Modifying copy of x

      auto c = [=]() { x = 42 ; } // Error: captured copy of '*this'
                                  // and lambda function is 'const'
    }
  };

.. /*


Resolution Option #2: Add True Lambda Capture-by-value **[\*]**
---------------------------------------------------------------------

Given that the semantically consistent resolution would break
current standard behavior, a new capture mechanism is necessary
to provide semantically consistent capture-by-value semantics for
lambda expressions within non-status member functions.

Extend the *capture-default* and *simple-capture* to include:

  |  *capture-default*:
    |     &
    |     =
    |     \*
  |  *simple-capture*:
    |    *identifier*
    |    & *identifier*
    |    **this**
    |    **\*this**


The *simple-capture* **\*this** declares that **\*this**
is to be captured by value.
The *capture-default* **[\*]** declares that the default capture
is by value, including **\*this** if the lambda
expression appears within a non-static member function.
Outside of a non-static member function the *capture-default* **[\*]**
is identical to the *capture-default* **[=]**.



